#!/usr/bin/env python3
"""
AllerMind Minimal Tahmin Sistemi
===============================

Bu sistem hi√ßbir dƒ±≈ü k√ºt√ºphane kullanmadan, pkl modellerini analiz eder
ve basit risk hesaplamalarƒ± yapar.

Kullanƒ±m: python minimal_predictor.py
"""

import pickle
import random
import math
from datetime import datetime
from pathlib import Path

class MinimalAllerMindPredictor:
    """Minimal AllerMind tahmin sistemi"""
    
    def __init__(self):
        self.models_dir = Path("pkl_models")
        
        # Grup bilgileri
        self.groups = {
            1: {
                'name': '≈ûiddetli Alerjik Grup',
                'description': 'Yoƒüun polen alerjisi, astƒ±m',
                'risk_threshold': 30,
                'polen_weight': 3.5,
                'pollution_weight': 2.0,
                'weather_weight': 1.8
            },
            2: {
                'name': 'Hafif-Orta Grup',
                'description': 'Hafif alerjik reaksiyonlar',
                'risk_threshold': 40,
                'polen_weight': 1.6,
                'pollution_weight': 3.5,
                'weather_weight': 1.8
            },
            3: {
                'name': 'Genetik Yatkƒ±nlƒ±ƒüƒ± Olan Grup',
                'description': 'Aile ge√ßmi≈üi olan bireyler',
                'risk_threshold': 35,
                'polen_weight': 2.2,
                'pollution_weight': 2.2,
                'weather_weight': 2.0
            },
            4: {
                'name': 'Kaliteli Ya≈üam Tercih Eden Grup',
                'description': 'Konfor odaklƒ± ya≈üam',
                'risk_threshold': 45,
                'polen_weight': 2.8,
                'pollution_weight': 3.0,
                'weather_weight': 2.2
            },
            5: {
                'name': 'Hassas Grup (√áocuk/Ya≈ülƒ±)',
                'description': 'Ya≈ülƒ±lar ve √ßocuklar',
                'risk_threshold': 25,
                'polen_weight': 1.4,
                'pollution_weight': 1.2,
                'weather_weight': 1.4
            }
        }
        
        # ≈ûehir koordinatlarƒ±
        self.cities = {
            'ankara': (39.9334, 32.8597, 1.2),  # lat, lon, city_factor
            'istanbul': (41.0082, 28.9784, 1.5),
            'izmir': (38.4237, 27.1428, 1.3),
            'bursa': (40.1826, 29.0665, 1.2),
            'antalya': (36.8969, 30.7133, 1.1),
            'adana': (37.0000, 35.3213, 1.3),
            'konya': (37.8667, 32.4833, 1.0),
            'gaziantep': (37.0662, 37.3833, 1.2),
            'kayseri': (38.7312, 35.4787, 1.1),
            'mersin': (36.8000, 34.6333, 1.2)
        }
    
    def analyze_models(self):
        """Model dosyalarƒ±nƒ± analiz et"""
        print("üîç MODEL DOSYALARI ANALƒ∞Zƒ∞")
        print("="*50)
        
        pkl_files = list(self.models_dir.glob("*.pkl"))
        
        if not pkl_files:
            print("‚ùå Hi√ß .pkl dosyasƒ± bulunamadƒ±!")
            return False
        
        print(f"üì¶ Bulunan {len(pkl_files)} model dosyasƒ±:")
        
        successful_loads = 0
        
        for i, pkl_file in enumerate(pkl_files, 1):
            try:
                file_size = pkl_file.stat().st_size / (1024 * 1024)
                print(f"\n{i:2d}. {pkl_file.name}")
                print(f"    üìè Boyut: {file_size:.1f} MB")
                
                # Modeli y√ºklemeyi dene
                with open(pkl_file, 'rb') as f:
                    model_package = pickle.load(f)
                
                print(f"    ‚úÖ Ba≈üarƒ±yla y√ºklendi")
                print(f"    üìã ƒ∞√ßerik:")
                
                for key, value in model_package.items():
                    print(f"       üìå {key}: {type(value).__name__}")
                    
                    if key == 'features' and hasattr(value, '__len__'):
                        print(f"          ‚îî‚îÄ {len(value)} √∂zellik")
                    elif key == 'model':
                        model_type = str(type(value)).split('.')[-1].replace("'>", "")
                        print(f"          ‚îî‚îÄ {model_type}")
                
                successful_loads += 1
                
            except Exception as e:
                print(f"    ‚ùå Y√ºkleme hatasƒ±: {str(e)[:50]}...")
        
        print(f"\nüìä √ñZET: {successful_loads}/{len(pkl_files)} model ba≈üarƒ±yla analiz edildi")
        return successful_loads > 0
    
    def get_city_info(self, city_name):
        """≈ûehir bilgisini al"""
        city_key = city_name.lower()
        
        # T√ºrk√ße karakter temizliƒüi
        replacements = {'ƒ±': 'i', 'ƒü': 'g', '√º': 'u', '≈ü': 's', '√∂': 'o', '√ß': 'c'}
        for tr_char, en_char in replacements.items():
            city_key = city_key.replace(tr_char, en_char)
        
        if city_key in self.cities:
            return self.cities[city_key]
        else:
            # Varsayƒ±lan: Ankara
            print(f"‚ö†Ô∏è '{city_name}' bulunamadƒ±, Ankara kullanƒ±lƒ±yor")
            return self.cities['ankara']
    
    def generate_environmental_data(self, city_name, date_str):
        """√áevresel veri sim√ºle et"""
        lat, lon, city_factor = self.get_city_info(city_name)
        
        # Tarih i≈üleme
        try:
            date_obj = datetime.strptime(date_str, '%Y-%m-%d')
            month = date_obj.month
        except:
            month = datetime.now().month
        
        # Mevsimsel fakt√∂rler
        season_factors = {
            'polen_spring': 1.8 if month in [3, 4, 5] else 1.0,
            'summer_heat': 1.3 if month in [6, 7, 8] else 1.0,
            'autumn_mild': 1.1 if month in [9, 10, 11] else 1.0,
            'winter_low': 0.6 if month in [12, 1, 2] else 1.0
        }
        
        # Rastgele √ßevresel veriler √ºret
        data = {
            # Polen verileri
            'tree_pollen': random.uniform(5, 80) * season_factors['polen_spring'],
            'grass_pollen': random.uniform(3, 60) * season_factors['polen_spring'],
            'weed_pollen': random.uniform(2, 40) * season_factors['autumn_mild'],
            
            # Hava kalitesi
            'pm25': random.uniform(8, 60) * city_factor,
            'pm10': random.uniform(15, 100) * city_factor,
            'no2': random.uniform(10, 70) * city_factor,
            'ozone': random.uniform(40, 160) * season_factors['summer_heat'],
            'so2': random.uniform(2, 35) * city_factor,
            'co': random.uniform(0.5, 4.0) * city_factor,
            
            # Meteoroloji
            'temperature': random.uniform(0, 40) + (month - 6) * 2,
            'humidity': random.uniform(25, 90),
            'wind_speed': random.uniform(1, 25),
            'pressure': random.uniform(995, 1025),
            'uv_index': max(0, random.uniform(0, 11) * season_factors['summer_heat']),
            'visibility': random.uniform(2, 30),
            'cloud_cover': random.uniform(0, 100),
            'precipitation': max(0, random.uniform(0, 15))
        }
        
        return data
    
    def calculate_risk_score(self, env_data, group_id):
        """Grup √∂zelinde risk skoru hesapla"""
        group = self.groups[group_id]
        
        # Polen bile≈üeni
        polen_score = (
            env_data['tree_pollen'] * 1.2 +
            env_data['grass_pollen'] * 1.0 +
            env_data['weed_pollen'] * 0.8
        ) / 3
        
        # Kirlilik bile≈üeni
        pollution_score = (
            env_data['pm25'] * 1.5 +
            env_data['pm10'] * 1.2 +
            env_data['no2'] * 1.3 +
            env_data['ozone'] / 2 +
            env_data['so2'] * 1.1 +
            env_data['co'] * 20
        ) / 6
        
        # Hava durumu bile≈üeni
        temp_comfort = abs(env_data['temperature'] - 22)  # 22¬∞C ideal
        humidity_discomfort = abs(env_data['humidity'] - 55)  # 55% ideal
        
        weather_score = (
            temp_comfort * 2 +
            humidity_discomfort / 2 +
            env_data['wind_speed'] / 3 +
            (100 - env_data['visibility']) +
            env_data['precipitation'] * 3
        ) / 5
        
        # Grup aƒüƒ±rlƒ±klƒ± toplam
        total_score = (
            polen_score * group['polen_weight'] +
            pollution_score * group['pollution_weight'] +
            weather_score * group['weather_weight']
        ) / (group['polen_weight'] + group['pollution_weight'] + group['weather_weight'])
        
        # 0-100 arasƒ± normalize et
        risk_score = min(100, max(0, total_score))
        
        return risk_score
    
    def evaluate_risk_level(self, risk_score, group_id):
        """Risk seviyesini deƒüerlendir"""
        threshold = self.groups[group_id]['risk_threshold']
        
        if risk_score <= threshold * 0.6:
            return "D√º≈ü√ºk Risk üü¢", "Outdoor aktiviteler g√ºvenli", "green"
        elif risk_score <= threshold * 0.8:
            return "D√º≈ü√ºk-Orta Risk üü°", "Kƒ±sa s√ºreli outdoor aktivite", "yellow"
        elif risk_score <= threshold:
            return "Orta Risk üü†", "Dikkatli outdoor aktivite", "orange"
        elif risk_score <= threshold * 1.2:
            return "Y√ºksek Risk üî¥", "Indoor kalmanƒ±z √∂nerilir", "red"
        else:
            return "√áok Y√ºksek Risk üö®", "Kesinlikle indoor kalƒ±n", "darkred"
    
    def calculate_safe_hours(self, risk_score):
        """G√ºvenli outdoor saat hesapla"""
        if risk_score <= 20:
            return 24
        elif risk_score <= 40:
            return 18
        elif risk_score <= 60:
            return 12
        elif risk_score <= 80:
            return 6
        else:
            return 2
    
    def predict_for_group(self, group_id, city_name, date_str):
        """Grup i√ßin tahmin yap"""
        if group_id not in self.groups:
            return {'error': f'Ge√ßersiz grup ID: {group_id}'}
        
        # √áevresel veri √ºret
        env_data = self.generate_environmental_data(city_name, date_str)
        
        # Risk hesapla
        risk_score = self.calculate_risk_score(env_data, group_id)
        
        # Risk seviyesi
        risk_level, recommendation, color = self.evaluate_risk_level(risk_score, group_id)
        
        # G√ºvenli saatler
        safe_hours = self.calculate_safe_hours(risk_score)
        
        return {
            'group_id': group_id,
            'group_name': self.groups[group_id]['name'],
            'city': city_name,
            'date': date_str,
            'risk_score': round(risk_score, 1),
            'risk_level': risk_level,
            'recommendation': recommendation,
            'safe_hours': safe_hours,
            'color': color,
            'env_data': {k: round(v, 1) for k, v in env_data.items()}
        }
    
    def predict_all_groups(self, city_name, date_str):
        """T√ºm gruplar i√ßin tahmin"""
        results = {}
        
        for group_id in range(1, 6):
            results[group_id] = self.predict_for_group(group_id, city_name, date_str)
        
        return results
    
    def print_report(self, results):
        """Rapor yazdƒ±r"""
        if isinstance(results, dict) and 'group_id' in results:
            # Tek grup
            self._print_single_result(results)
        else:
            # √áoklu grup
            self._print_multi_results(results)
    
    def _print_single_result(self, result):
        """Tek grup raporu"""
        print(f"\n{'='*60}")
        print(f"üåø ALLERMIND ALERJƒ∞ Rƒ∞SK RAPORU")
        print(f"{'='*60}")
        print(f"üë• Grup: {result['group_name']} (#{result['group_id']})")
        print(f"üìç ≈ûehir: {result['city'].title()}")
        print(f"üìÖ Tarih: {result['date']}")
        print(f"‚è∞ Analiz Zamanƒ±: {datetime.now().strftime('%H:%M:%S')}")
        
        print(f"\nüéØ TAHMƒ∞N SONU√áLARI:")
        print(f"{'-'*30}")
        print(f"Risk Skoru: {result['risk_score']}/100")
        print(f"Risk Seviyesi: {result['risk_level']}")
        print(f"G√ºvenli Outdoor Saat: {result['safe_hours']} saat/g√ºn")
        print(f"√ñneri: {result['recommendation']}")
        
        print(f"\nüå°Ô∏è √áEVRESEL KO≈ûULLAR (Sim√ºlasyon):")
        print(f"{'-'*40}")
        env = result['env_data']
        print(f"üå∏ Polen - Aƒüa√ß: {env['tree_pollen']} grains/m¬≥")
        print(f"üåæ Polen - √áimen: {env['grass_pollen']} grains/m¬≥")
        print(f"üåø Polen - Ot: {env['weed_pollen']} grains/m¬≥")
        print(f"üí® PM2.5: {env['pm25']} Œºg/m¬≥")
        print(f"üí® PM10: {env['pm10']} Œºg/m¬≥")
        print(f"üå°Ô∏è Sƒ±caklƒ±k: {env['temperature']}¬∞C")
        print(f"üíß Nem: {env['humidity']}%")
        print(f"üå¨Ô∏è R√ºzgar: {env['wind_speed']} km/h")
        print(f"‚òÄÔ∏è UV ƒ∞ndeks: {env['uv_index']}")
    
    def _print_multi_results(self, results):
        """√áoklu grup raporu"""
        first_result = list(results.values())[0]
        
        print(f"\n{'='*70}")
        print(f"üåø ALLERMIND - T√úM GRUPLAR Rƒ∞SK RAPORU")
        print(f"{'='*70}")
        print(f"üìç ≈ûehir: {first_result['city'].title()}")
        print(f"üìÖ Tarih: {first_result['date']}")
        print(f"‚è∞ Analiz: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        print(f"\nüìä GRUP BAZLI SONU√áLAR:")
        print(f"{'-'*70}")
        
        for group_id in sorted(results.keys()):
            result = results[group_id]
            if 'error' not in result:
                print(f"\n{group_id}. {result['group_name']}")
                print(f"   Risk: {result['risk_score']}/100 | {result['risk_level']}")
                print(f"   G√ºvenli: {result['safe_hours']}h | {result['recommendation']}")
        
        # En g√ºvenli ve en riskli gruplarƒ± bul
        safe_groups = []
        risky_groups = []
        
        for group_id, result in results.items():
            if 'error' not in result:
                if result['risk_score'] <= 30:
                    safe_groups.append(f"Grup {group_id}")
                elif result['risk_score'] >= 60:
                    risky_groups.append(f"Grup {group_id}")
        
        if safe_groups or risky_groups:
            print(f"\nüí° HIZLI √ñZET:")
            print(f"{'-'*30}")
            if safe_groups:
                print(f"üü¢ G√ºvenli Gruplar: {', '.join(safe_groups)}")
            if risky_groups:
                print(f"üî¥ Riskli Gruplar: {', '.join(risky_groups)}")
    
    def interactive_prediction(self):
        """ƒ∞nteraktif tahmin"""
        print(f"\n{'='*60}")
        print("üåø ALLERMIND Mƒ∞Nƒ∞MAL TAHMƒ∞N Sƒ∞STEMƒ∞")
        print(f"{'='*60}")
        print("Bu sistem hi√ßbir dƒ±≈ü k√ºt√ºphane kullanmadan √ßalƒ±≈üƒ±r!")
        
        # Model analizi
        print(f"\nüîç Model dosyalarƒ± kontrol ediliyor...")
        self.analyze_models()
        
        while True:
            # Grup se√ßimi
            print(f"\nüë• GRUP SE√áƒ∞Mƒ∞:")
            for gid, ginfo in self.groups.items():
                print(f"{gid}. {ginfo['name']}")
            print("0. T√ºm gruplar")
            
            try:
                choice = input("Grup se√ßin (0-5): ").strip()
                if choice == '0':
                    selected_group = None
                elif choice in ['1', '2', '3', '4', '5']:
                    selected_group = int(choice)
                else:
                    print("‚ùå Ge√ßersiz se√ßim!")
                    continue
            except:
                print("‚ùå Ge√ßersiz giri≈ü!")
                continue
            
            # ≈ûehir se√ßimi
            print(f"\nüèôÔ∏è ≈ûEHƒ∞R SE√áƒ∞Mƒ∞:")
            city_list = list(self.cities.keys())
            for i, city in enumerate(city_list[:5], 1):
                print(f"{i}. {city.title()}")
            
            city_input = input("≈ûehir adƒ± girin (veya Enter=Ankara): ").strip()
            city_name = city_input if city_input else "Ankara"
            
            # Tarih
            date_str = input("Tarih (YYYY-MM-DD) veya Enter=bug√ºn: ").strip()
            if not date_str:
                date_str = datetime.now().strftime('%Y-%m-%d')
            
            # Tahmin yap
            print(f"\nüîÑ Hesaplama yapƒ±lƒ±yor...")
            
            if selected_group:
                result = self.predict_for_group(selected_group, city_name, date_str)
                self.print_report(result)
            else:
                results = self.predict_all_groups(city_name, date_str)
                self.print_report(results)
            
            # Devam
            print(f"\n{'='*60}")
            again = input("Ba≈üka bir tahmin yapmak ister misiniz? (e/h): ")
            if again.lower() not in ['e', 'evet', 'y', 'yes']:
                break
        
        print(f"\nüëã AllerMind Minimal Predictor'ƒ± kullandƒ±ƒüƒ±nƒ±z i√ßin te≈üekk√ºrler!")

def main():
    """Ana fonksiyon"""
    print("üåø AllerMind Minimal Tahmin Sistemi")
    print("="*50)
    print("‚úÖ Hi√ßbir dƒ±≈ü k√ºt√ºphane gerektirmez!")
    print("üì¶ Model dosyalarƒ±nƒ± analiz eder")
    print("üßÆ Basit risk hesaplamalarƒ± yapar")
    
    # Dizin kontrol√º
    models_dir = Path("pkl_models")
    if not models_dir.exists():
        print(f"\n‚ùå '{models_dir}' klas√∂r√º bulunamadƒ±!")
        print("L√ºtfen bu scripti MODEL klas√∂r√º i√ßinde √ßalƒ±≈ütƒ±rƒ±n.")
        return
    
    predictor = MinimalAllerMindPredictor()
    predictor.interactive_prediction()

if __name__ == "__main__":
    main()
